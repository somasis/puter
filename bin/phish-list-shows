#!/usr/bin/env bash
#!/usr/bin/env nix-shell
#! nix-shell -i bash -p bash coreutils curl dateutils jq
# shellcheck shell=bash

# keep-sorted start skip_lines=1 prefix_order=type,,>,||
type \
    curl \
    dateadd \
    jq \
    phishin-auth-token \
    >/dev/null \
    || exit 1
# keep-sorted end

usage() {
    # shellcheck disable=SC2059
    [[ "$#" -eq 0 ]] || printf "$@" >&2

    cat >&2 <<EOF
usage: ${0##*/} [-lj] [-A <completeness>] [-S <sort>] [-V <venue>]
                [-d (<date>[..<end>])] [-n <count>] [-s <state>]
       ${0##*/} [-j] [-A <completeness>] [-D <dayofyear>] [-S <sort>]
       ${0##*/} [-Rj] <show>

List show dates performed by Phish, as catalogued by Phish.in.

options:
    -A <completeness>
        Filter shows by the completeness of their audio recording.
        Valid completeness values are "complete", "partial",
        "complete-or-partial" (the default), "missing", and "any".

    -D <dayofyear>
        Filter for shows which occurred on a given <dayofyear>.
        Due to the design of the Phish.in API, this option cannot
        be combined with options -V <venue>, -n <count>, -s <state>,
        or -l.

    -R
        Get all shows in a run; a run, being shows performed at the
        same venue, multiple days in a row, preceding or following
        the given <show> date. For example, given the show date
        2009-03-06, the shows 2009-03-07, and 2009-03-08 would also
        be printed. This option can only be used when querying for a
        specific show date.

    -S ("date" | "likes_count" | "duration" | "updated_at")[+-]
        Sort the shows listed in the requested order. If a plus is
        suffixed (or no symbol is provided), it will be sorted in
        ascending order. If a minus is suffixed, it will be printed
        in descending order. If no sort order is specified, the
        default order is determined by Phish.in's API defaults.

    -V <venue>
        Filter for shows played at <venue>. <venue> must match
        only one venue name; this is because, in order to avoid
        requiring the use of a pre-determined venue slug, we search
        for venues using <venue> as a query. If the query produces
        multiple results, all matching venues will be printed, so that
        the venue query may be narrowed down. Due to the design of
        Phish.in's API, this option cannot be combined with
        -D <dayofyear>.

    -d (<year> | <date> | <start>.. | ..<end> | <start>..<end>)
        Filter for shows which have occurred during <year>, or on
        <date>, on since <start>, or before <end>, or occurred
        on and between <start> and <end>. <start> and <end> can
        be a year or an ISO date.

    -l                  List shows liked by your (authenticated) user.
    -j                  Output show JSON data instead of listing dates.
    -n (<count> | all)  List at most <count> shows

    -s <stateabbr>
        Only list shows performed in <state>, USA. <stateabbr> should
        be formatted as an ISO 3166-2 country code.

    <show>              An ISO formatted date (ex. 1969-12-31)

see also: phish-show-notes, phishin-auth-token, phishin-like-show,
          the Phish.in project <https://phish.in>.

Kylie McClain <kylie@somas.is>
EOF
    [[ "$#" -eq 0 ]] || exit 1
    exit 64 # EX_USAGE
}

phishin_auth() {
    local -
    set +x
    : "${PHISHIN_USER_TOKEN:=$(phishin-auth-token)}" || exit 1
    export PHISHIN_USER_TOKEN
}

curl() {
    set -- \
        --globoff \
        --no-progress-meter --user-agent "${user_agent}" \
        ${PHISHIN_USER_TOKEN:+--variable %PHISHIN_USER_TOKEN} \
        ${PHISHIN_USER_TOKEN:+--expand-header X-Auth-Token:\ \{\{PHISHIN_USER_TOKEN\}\}} \
        "$@"
    command curl "$@"
}

shows() {
    if [[ -n "${day_of_year:-}" ]]; then
        curl \
            --fail-with-body \
            --get \
            ${audio_status:+-d audio_status="${audio_status}"} \
            ${sort:+-d sort="${sort}"} \
            -d "page=${page:?no \$page set}" \
            "https://phish.in/api/v2/shows/day_of_year/1970-${day_of_year:?no \$day_of_year set}"
    else
        curl \
            --fail-with-body \
            --get \
            ${audio_status:+-d audio_status="${audio_status}"} \
            ${sort:+-d sort="${sort}"} \
            ${end_date:+-d end_date="${end_date}"} \
            ${liked_by_user:+-d liked_by_user="${liked_by_user}"} \
            ${per_page:+-d per_page="${per_page}"} \
            ${start_date:+-d start_date="${start_date}"} \
            ${us_state:+-d us_state="${us_state}"} \
            ${venue_slug:+-d venue_slug="${venue_slug}"} \
            -d "page=${page:?no \$page set}" \
            "https://phish.in/api/v2/shows"
    fi
}

show() {
    : "${1:?error in show(): no date provided}"
    curl --fail-with-body --get "https://phish.in/api/v2/shows/${1}"
}

get_venue_slug() {
    : "${1:?error in get_venue_slug(): no venue search query provided}"

    local results result_count

    results=$(
        curl --fail-with-body --get \
            ${audio_status:+-d audio_status="${audio_status}"} \
            -d scope=venues \
            --variable "query=${1}" \
            --expand-url 'https://phish.in/api/v2/search/{{query:url}}'
    )

    results=$(<<<"$results" jq '.venues')
    result_count=$(jq 'length' <<<"$results")

    if [[ "$result_count" -eq 0 ]]; then
        printf 'error: no results for query\n' >&2
        exit 1
    elif [[ "$result_count" -gt 1 ]]; then
        mapfile -t results < <(<<<"$results" jq -r '.[] | (.name, .other_names[])')
        printf '%s\n' \
            'error: got multiple results for query; narrow down your query' \
            'matching venues:' \
            >&2
        printf '    - %s\n' "${results[@]}" >&2
        exit 1
    fi

    <<<"$results" jq -r '.[0].slug'
}

fetch_run() {
    : "${anchor_show_date:?error in fetch_run(): \$anchor_show_date is unset}"
    : "${anchor_show_data:?error in fetch_run(): \$anchor_show_data is unset}"

    : "${1:?error in fetch_run(): no direction provided}"

    local expected_show_date
    local next_show_date next_show_data

    local direction direction_node

    case "$1" in
        prev)
            direction=-1d
            direction_node=.previous_show_date
            ;;
        next)
            direction=+1d
            direction_node=.next_show_date
            ;;
        *) return 1 ;;
    esac

    case "$audio_status" in
        complete | partial | complete-or-partial) direction_node+=_with_audio ;;
    esac

    while :; do
        expected_show_date=$(dateadd "${anchor_show_date}" "${direction}")
        expected_show_venue=$(jq -r '.venue_name' <<<"${anchor_show_data}")

        # >&2 echo "expected ${1} of ${anchor_show_date}: $expected_show_date"

        next_show_date=$(jq -r "${direction_node}" <<<"${anchor_show_data}")
        next_show_data=$(show "${next_show_date}")
        next_show_venue=$(jq -r '.venue_name' <<<"${next_show_data}")

        if [[ "$next_show_venue" == "$expected_show_venue" ]] \
            && [[ "$next_show_date" == "$expected_show_date" ]]; then
            # >&2 echo "show ${1} of ${anchor_show_date}: $next_show_date"
            printf '%s\n' "${next_show_data}"
        else
            # >&2 echo "break; show ${1} was not $expected_show_date (got ${next_show_date})"
            break
        fi

        anchor_show_data="${next_show_data}"
        anchor_show_date="${next_show_date}"
    done
}

set -euo pipefail

user_agent='phish-cli <kylie@somas.is>'
mode=list
list_run=false

audio_status=complete_or_partial
day_of_year=
end_date=
liked_by_user=false
page=
start_date=
us_state=
sort=
venue_slug=

# shellcheck disable=SC2209
output=date
max_entries=all

BASH_ARGV0="${0##*/}"

while getopts A:D:S:V:d:Rjln:rs: opt; do
    case "$opt" in
        A)
            case "${OPTARG}" in
                complete | partial | complete-or-partial | missing | any)
                    audio_status=${OPTARG/-/_}
                    ;;
                # '') usage 'error: no audio status provided\n' ;;
                *) usage 'error: unknown audio status value: %s\n' "${OPTARG}" ;;
            esac
            ;;

        D)
            day_of_year="${OPTARG:?error: -D: no day of year provided}"
            [[ "${day_of_year}" =~ ^([0-9]{2})-([0-9]{2})$ ]] \
                || usage 'error: -D: invalid argument\n'
            ;;

        R)
            list_run=true
            ;;

        S)
            case "${OPTARG:?error: -S: no sort provided}" in
                date+ | likes_count+ | duration+ | updated_at+ | \
                    date | likes_count | duration | updated_at) sort="${OPTARG%+}:asc" ;;
                date- | likes_count- | duration- | updated_at-) sort="${OPTARG%-}:desc" ;;
                *) usage 'error: -S: invalid argument\n' ;;
            esac
            ;;

        V)
            : "${OPTARG:?error: -V: no venue provided}"

            venue_slug=$(get_venue_slug "${OPTARG}")
            ;;

        d)
            : "${OPTARG:?error: -d: no date provided}"

            if [[ "${OPTARG}" =~ ^([0-9]{4}-[0-9]{2}-[0-9]{2}|)..([0-9]{4}-[0-9]{2}-[0-9]{2}|)$ ]]; then
                start_date=${BASH_REMATCH[1]}
                end_date=${BASH_REMATCH[2]}
                unset day_of_year
            elif [[ "${OPTARG}" =~ ^([0-9]{4}-[0-9]{2}-[0-9]{2})$ ]]; then
                start_date=${BASH_REMATCH[0]}
                unset end_date day_of_year
            elif [[ "${OPTARG}" =~ ^([0-9]{4}|)..([0-9]{4}|)?$ ]]; then
                start_date=${BASH_REMATCH[1]:+${BASH_REMATCH[1]}-01-01}
                end_date=${BASH_REMATCH[2]:+${BASH_REMATCH[2]}-01-01}
                unset day_of_year
            elif [[ "${OPTARG}" =~ ^([0-9]{4})$ ]]; then
                start_date=${BASH_REMATCH[1]}-01-01
                end_date=${BASH_REMATCH[1]}-12-31
                unset day_of_year
            else
                usage 'error: -d: invalid argument format: %s\n' "${OPTARG}"
            fi
            ;;

        j) output=json ;;

        l) liked_by_user=true ;;

        n)
            if ! [[ "${OPTARG:?error: -n: no number argument provided}" =~ ^[0-9]+$ ]]; then
                usage 'error: -n: invalid argument\n'
            fi

            max_entries="${OPTARG}"
            ;;

        s)
            : "${OPTARG:?error: -s: no state abbreviation provided}"
            us_state="${OPTARG^^}"
            ;;

        ?) usage '' ;;
    esac
done
shift $((OPTIND - 1))

per_page=180 # half a year, which is roughly the length of a single tour
if [[ "$max_entries" == 'all' ]]; then
    : use defaults
elif [[ "$max_entries" -le 1000 ]]; then
    per_page="${max_entries}"
    max_pages=1
fi

[[ "${1:-}" == --help ]] && usage

if [[ "$#" -gt 1 ]]; then
    usage 'error: only one show may be provided\n'
elif [[ "$#" -eq 1 ]]; then
    mode=show
fi

case "$mode" in
    show)
        if [[ "$list_run" == true ]]; then
            anchor_show_data=$(show "${1:?error: no show date provided}")
            anchor_show_date=$(jq -r .date <<<"$anchor_show_data")

            mapfile -t run_data < <(
                {
                    fetch_run prev
                    printf '%s\n' "${anchor_show_data}"
                    fetch_run next
                } | sort -u
            )

            if [[ "$output" == 'date' ]]; then
                jq -r .date <<<"${run_data[*]}"
            elif [[ "$output" == 'json' ]]; then
                jq -r <<<"${run_data[*]}"
            fi
        else
            show_data=$(show "${1:?error: no show date provided}")

            if [[ "$output" == 'date' ]]; then
                jq -r .date <<<"$show_data"
            elif [[ "$output" == 'json' ]]; then
                jq -r <<<"$show_data"
            fi
        fi
        ;;

    list)
        if [[ "$liked_by_user" == true ]]; then
            phishin_auth
        fi

        page=1
        response=
        entries_on_page=
        entries=
        entries_expected=
        while :; do
            # printf '[retrieving page %s/%s; %s/%s entries]\n' \
            #     "${page}" \
            #     "${total_pages:-${pages_expected:-?}}" \
            #     "${entries:-?}" \
            #     "${entries_expected:-?}" \
            #     >&2

            if ! response=$(shows "${page}") || [[ -z "$response" ]]; then
                printf 'error getting shows (page %i): %s\n' \
                    "${page}" "$(jq -cr . <<<"$response")"
                exit 1
            fi

            page=$(jq -er '.current_page // 1' <<<"$response")

            entries_on_page=$(jq -er '.shows | length' <<<"$response")
            entries_expected=$(
                jq -er \
                    --arg entries_on_page "$entries_on_page" \
                    '.total_entries // $entries_on_page' \
                    <<<"$response"
            )

            [[ "$entries_on_page" -gt 0 ]] || break
            if [[ "$output" == 'date' ]]; then
                jq -cr '.shows[].date' <<<"${response}"
            elif [[ "$output" == 'json' ]]; then
                jq -er '.shows[]' <<<"${response}"
            fi

            entries=$((entries + entries_on_page))
            [[ "$entries" -eq "$entries_expected" ]] && break

            [[ -v max_pages ]] && [[ "$page" -ge "$max_pages" ]] && break

            page=$((page + 1))
        done \
            | if [[ "$output" == 'json' ]]; then jq -c; else cat; fi
        ;;
esac
