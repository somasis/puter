#!/usr/bin/env bash
#!/usr/bin/env nix-shell
#! nix-shell -i bash -p bash coreutils curl dateutils jq
# shellcheck shell=bash

# keep-sorted start skip_lines=1 prefix_order=type,,>,||
type \
    curl \
    dateadd \
    jq \
    phishin-auth-token \
    >/dev/null \
    || exit 1
# keep-sorted end

usage() {
    # shellcheck disable=SC2059
    [[ "$#" -eq 0 ]] || printf "$@" >&2

    cat >&2 <<EOF
usage: ${0##*/} [-lrj] [-A <completeness>] [-S <sort>] [-n <count>]
                [-s <state>] [-d (<date>[..<end>])]
       ${0##*/} [-j] [-A <completeness>] [-D <dayofyear>] [-S <sort>]
       ${0##*/} [-Rj] <show>

List show dates performed by Phish, as catalogued by Phish.in.

options:
    -A <completeness>
        Filter shows by the completeness of their audio recording.
        Valid completeness values are "complete", "partial",
        "complete-or-partial" (the default), "missing", and "any".

    -D <dayofyear>
        Filter for shows which occurred on a given <dayofyear>.

    -R
        Get all shows in a run; a run, being shows performed multiple
        days in a row potentially preceding or following the given
        <show> date. For example, given the show date 2009-03-06, the
        shows 2009-03-07, and 2009-03-08 will also be printed.

    -S ("date" | "likes_count" | "duration" | "updated_at")[+-]
        Sort the shows listed in the requested order. If a plus is
        suffixed (or no symbol is provided), it will be sorted in
        ascending order. If a minus is suffixed, it will be printed
        in descending order. If no sort order is specified, the
        default order is determined by Phish.in's API defaults.

    -d (<year> | <date> | <start>.. | ..<end> | <start>..<end>)
        Filter for shows which have occurred during <year>, or on
        <date>, on since <start>, or before <end>, or occurred
        on and between <start> and <end>. <start> and <end> can
        be a year or an ISO date.

    -l                  List shows liked by your (authenticated) user.
    -j                  Output show JSON data instead of listing dates.
    -n (<count> | all)  List at most <count> shows

    -s <stateabbr>
        Only list shows performed in <state>, USA. <stateabbr> should
        be formatted as an ISO 3166-2 country code.

    <show>              An ISO formatted date (ex. 1969-12-31)

see also: phish-show-notes, phishin-auth-token, phishin-like-show,
          the Phish.in project <https://phish.in>.

Kylie McClain <kylie@somas.is>
EOF
    [[ "$#" -eq 0 ]] || exit 1
    exit 64 # EX_USAGE
}

phishin_auth() {
    local -
    set +x
    : "${PHISHIN_USER_TOKEN:=$(phishin-auth-token)}" || exit 1
    export PHISHIN_USER_TOKEN
}

curl() {
    set -- \
        --no-progress-meter --user-agent "${user_agent}" \
        ${PHISHIN_USER_TOKEN:+--variable %PHISHIN_USER_TOKEN} \
        ${PHISHIN_USER_TOKEN:+--expand-header X-Auth-Token:\ \{\{PHISHIN_USER_TOKEN\}\}} \
        "$@"
    command curl "$@"
}

shows() {
    if [[ -n "${day_of_year:-}" ]]; then
        curl \
            --fail-with-body \
            --get \
            ${audio_status:+-d audio_status="${audio_status}"} \
            ${sort:+-d sort="${sort}"} \
            -d "page=${page:?no \$page set}" \
            "https://phish.in/api/v2/shows/day_of_year/1970-${day_of_year:?no \$day_of_year set}"
    else
        curl \
            --fail-with-body \
            --get \
            ${audio_status:+-d audio_status="${audio_status}"} \
            ${sort:+-d sort="${sort}"} \
            ${end_date:+-d end_date="${end_date}"} \
            ${liked_by_user:+-d liked_by_user="${liked_by_user}"} \
            ${per_page:+-d per_page="${per_page}"} \
            ${start_date:+-d start_date="${start_date}"} \
            ${us_state:+-d us_state="${us_state}"} \
            -d "page=${page:?no \$page set}" \
            "https://phish.in/api/v2/shows"
    fi
}

show() {
    : "${1:?error in show(): no date provided}"
    curl --fail-with-body --get "https://phish.in/api/v2/shows/${1}"
}

fetch_run() {
    : "${anchor_show_date:?error in fetch_run(): \$anchor_show_date is unset}"
    : "${anchor_show_data:?error in fetch_run(): \$anchor_show_data is unset}"

    : "${1:?error in fetch_run(): no direction provided}"

    local expected_show_date
    local next_show_date next_show_data

    local direction direction_node

    case "$1" in
        prev)
            direction=-1d
            direction_node=.previous_show_date
            ;;
        next)
            direction=+1d
            direction_node=.next_show_date
            ;;
        *) return 1 ;;
    esac

    case "$audio_status" in
        complete | partial | complete-or-partial) direction_node+=_with_audio ;;
    esac

    while :; do
        expected_show_date=$(dateadd "${anchor_show_date}" "${direction}")

        # >&2 echo "expected ${1} of ${anchor_show_date}: $expected_show_date"

        next_show_date=$(jq -r "${direction_node}" <<<"${anchor_show_data}")
        next_show_data=$(show "${next_show_date}")

        if [[ "$next_show_date" == "$expected_show_date" ]]; then
            # >&2 echo "show ${1} of ${anchor_show_date}: $next_show_date"
            printf '%s\n' "${next_show_data}"
        else
            # >&2 echo "break; show ${1} was not $expected_show_date (got ${next_show_date})"
            break
        fi

        anchor_show_data="${next_show_data}"
        anchor_show_date="${next_show_date}"
    done
}

set -euo pipefail

user_agent='phish-cli <kylie@somas.is>'
mode=list
list_run=false

audio_status=complete_or_partial
day_of_year=
end_date=
liked_by_user=false
page=
start_date=
us_state=
sort=

# shellcheck disable=SC2209
output=date
max_entries=all

BASH_ARGV0="${0##*/}"

while getopts A:D:S:d:Rjln:rs: opt; do
    case "$opt" in
        A)
            case "${OPTARG}" in
                complete | partial | complete-or-partial | missing | any)
                    audio_status=${OPTARG/-/_}
                    ;;
                # '') usage 'error: no audio status provided\n' ;;
                *) usage 'error: unknown audio status value: %s\n' "${OPTARG}" ;;
            esac
            ;;

        D)
            day_of_year=${OPTARG:?error: -D: no day of year provided}
            [[ "${day_of_year}" =~ ^([0-9]{2})-([0-9]{2})$ ]] \
                || usage 'error: -D: invalid argument\n'
            ;;

        S)
            sort="${OPTARG:?error: -S: no sort provided}"

        R)
            list_run=true
            ;;

            case "${sort}" in
                date+ | likes_count+ | duration+ | updated_at+ | \
                    date | likes_count | duration | updated_at) sort="${sort%+}:asc" ;;
                date- | likes_count- | duration- | updated_at-) sort="${sort%-}:desc" ;;
                *) usage 'error: -S: invalid argument\n' ;;
            esac
            ;;

        d)
            : "${OPTARG:?error: -d: no date provided}"

            if [[ "${OPTARG}" =~ ^([0-9]{4}-[0-9]{2}-[0-9]{2}|)..([0-9]{4}-[0-9]{2}-[0-9]{2}|)$ ]]; then
                start_date=${BASH_REMATCH[1]}
                end_date=${BASH_REMATCH[2]}
                unset day_of_year
            elif [[ "${OPTARG}" =~ ^([0-9]{4}-[0-9]{2}-[0-9]{2})$ ]]; then
                start_date=${BASH_REMATCH[0]}
                unset end_date day_of_year
            elif [[ "${OPTARG}" =~ ^([0-9]{4}|)..([0-9]{4}|)?$ ]]; then
                start_date=${BASH_REMATCH[1]:+${BASH_REMATCH[1]}-01-01}
                end_date=${BASH_REMATCH[2]:+${BASH_REMATCH[2]}-01-01}
                unset day_of_year
            elif [[ "${OPTARG}" =~ ^([0-9]{4})$ ]]; then
                start_date=${BASH_REMATCH[1]}-01-01
                end_date=${BASH_REMATCH[1]}-12-31
                unset day_of_year
            else
                usage 'error: -d: invalid argument format: %s\n' "${OPTARG}"
            fi
            ;;

        j) output=json ;;

        l) liked_by_user=true ;;

        n)
            if ! [[ "${OPTARG:?error: -n: no number argument provided}" =~ ^[0-9]+$ ]]; then
                usage 'error: -n: invalid argument\n'
            fi

            max_entries="${OPTARG}"
            ;;

        s)
            us_state="${OPTARG:?error: -s: no state abbreviation provided}"
            us_state="${us_state^^}"
            ;;

        ?) usage '' ;;
    esac
done
shift $((OPTIND - 1))

per_page=180 # half a year, which is roughly the length of a single tour
if [[ "$max_entries" == 'all' ]]; then
    : use defaults
elif [[ "$max_entries" -le 1000 ]]; then
    per_page="${max_entries}"
    max_pages=1
fi

[[ "${1:-}" == --help ]] && usage

if [[ "$#" -gt 1 ]]; then
    usage 'error: only one show may be provided\n'
elif [[ "$#" -eq 1 ]]; then
    mode=show
fi

case "$mode" in
    show)
        if [[ "$list_run" == true ]]; then
            anchor_show_data=$(show "${1:?error: no show date provided}")
            anchor_show_date=$(jq -r .date <<<"$anchor_show_data")

            mapfile -t run_data < <(
                {
                    fetch_run prev
                    printf '%s\n' "${anchor_show_data}"
                    fetch_run next
                } | sort -u
            )

            if [[ "$output" == 'date' ]]; then
                jq -r .date <<<"${run_data[*]}"
            elif [[ "$output" == 'json' ]]; then
                jq -r <<<"${run_data[*]}"
            fi
        else
            show_data=$(show "${1:?error: no show date provided}")

            if [[ "$output" == 'date' ]]; then
                jq -r .date <<<"$show_data"
            elif [[ "$output" == 'json' ]]; then
                jq -r <<<"$show_data"
            fi
        fi
        ;;

    list)
        if [[ "$liked_by_user" == true ]]; then
            phishin_auth
        fi

        page=1
        response=
        entries_on_page=
        entries=
        entries_expected=
        while :; do
            # printf '[retrieving page %s/%s; %s/%s entries]\n' \
            #     "${page}" \
            #     "${total_pages:-${pages_expected:-?}}" \
            #     "${entries:-?}" \
            #     "${entries_expected:-?}" \
            #     >&2

            if ! response=$(shows "${page}") || [[ -z "$response" ]]; then
                printf 'error getting shows (page %i): %s\n' \
                    "${page}" "$(jq -cr . <<<"$response")"
                exit 1
            fi

            page=$(jq -er '.current_page // 1' <<<"$response")

            entries_on_page=$(jq -er '.shows | length' <<<"$response")
            entries_expected=$(
                jq -er \
                    --arg entries_on_page "$entries_on_page" \
                    '.total_entries // $entries_on_page' \
                    <<<"$response"
            )

            [[ "$entries_on_page" -gt 0 ]] || break
            if [[ "$output" == 'date' ]]; then
                jq -cr '.shows[].date' <<<"${response}"
            elif [[ "$output" == 'json' ]]; then
                jq -er '.shows[]' <<<"${response}"
            fi

            entries=$((entries + entries_on_page))
            [[ "$entries" -eq "$entries_expected" ]] && break

            [[ -v max_pages ]] && [[ "$page" -ge "$max_pages" ]] && break

            page=$((page + 1))
        done \
            | if [[ "$output" == 'json' ]]; then jq -c; else cat; fi
        ;;
esac
