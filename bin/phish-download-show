#!/usr/bin/env bash
#!/usr/bin/env nix-shell
#! nix-shell -i bash -p bash coreutils curl diffutils jq libarchive tageditor
# shellcheck shell=bash

# keep-sorted start skip_lines=1 prefix_order=type,,>,||
type \
    bsdtar \
    cmp \
    curl \
    jq \
    mktemp \
    tageditor \
    >/dev/null \
    || exit 1
# keep-sorted end

set -euo pipefail

usage() {
    # shellcheck disable=SC2059
    [[ "$#" -eq 0 ]] || printf "$@" >&2

    cat >&2 <<EOF
usage: ${0##*/} [-Zvz] <show>

Download a show from Phish.in to the working directory, improving the
downloaded ZIP archive with better tagging, and extracting it to an
appropriately named subdirectory of the working directory. After
downloading, improving tags, and extracting the archive, print the
extracted directory path on standard output.

options:
    -Z              Keep downloaded archive, don't delete it after
                    extracting it to the working directory.
    -v              Be more verbose, showing commands being ran.
    -z              Do not extract the archive; download it and exit.
    <show>          An ISO formatted date (ex. 1983-12-02).

see also: the Phish.in project <https://phish.in>.

Kylie McClain <kylie@somas.is>
EOF
    [[ "$#" -eq 0 ]] || exit 1
    exit 64 # EX_USAGE
}

edo() {
    local arg string
    string="$"
    for arg; do
        if [[ "${arg@Q}" == "'$arg'" ]] && ! [[ "${arg}" =~ [[:blank:]] ]]; then
            string+=" $arg"
        else
            string+=" ${arg@Q}"
        fi
    done

    if [[ "${verbosity}" -ge 1 ]]; then
        printf '%s\n' "$string" >&2 || :
    fi

    "$@"
}

curl() {
    command curl --location --user-agent 'phish-cli <kylie@somas.is>' "$@"
}

phishin() {
    jq -cr "$@" <<<"${phishin_show_data}"
}

keep_archive=false
only_download=false
verbosity=0
while getopts :Zvz opt; do
    case "$opt" in
        Z) keep_archive=true ;;
        v) verbosity=$((verbosity + 1)) ;;
        z) only_download=true ;;
        ?) usage '' ;;
    esac
done
shift $((OPTIND - 1))

[[ "${1:-}" == --help ]] && usage

[[ "$#" -eq 1 ]] || usage 'error: incorrect number of arguments (1 required)\n'

[[ "$1" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] \
    || usage 'error: invalid show argument format (YYYY-MM-DD required)\n'

show="$1"
shift

# Request that Phish.in generate a ZIP archive of the album, polling until it
# is actually made available to download if we end up making it generate one.
while :; do
    request_album_zip=$(
        jq -nc '{date:$show}' --arg show "$show" \
            | curl --no-progress-meter --json @- \
                'https://phish.in/api/v2/shows/request_album_zip'
    )

    if jq -re '.message == "Album already generated"' <<<"${request_album_zip}" >/dev/null; then
        break
    else
        sleep 15
    fi
done

# shellcheck disable=SC2310
if ! phishin_show_data=$(curl --no-progress-meter --fail "https://phish.in/api/v2/shows/$show"); then
    printf 'error: failed to download show data for %s\n' "${show}" >&2
    exit 1
fi

near_show_data=

# Collapse the data a bit and create a nice filename
# ex. Phish - 2000-05-23 Roseland Ballroom, New York, NY [SBD] [Complete]
show_download=$(
    phishin '{
        album_zip_url,
        updated_at,
        filename: (
            [
                "Phish - \(.date) \(.venue_name), \(.venue.location)",
                ((
                    ( .tags | map(.name))
                        + [
                            (.audio_status
                                | (
                                    (.[0:1] | ascii_upcase)
                                        + .[1:]
                                )
                            )
                        ]
                ) | map(" [\(.)]") | join(""))
            ] | join("")
        )
    }'
)

filename=$(jq -r .filename <<<"${show_download}")
directory="${PWD}/${filename}"
zip="${directory}.zip"

album_zip_url=$(jq -r .album_zip_url <<<"${show_download}")

near_show_data=$(
    if [[ -f "${directory}"/phishin.json ]]; then
        cat "${directory}"/phishin.json
    elif [[ -f "${zip}" ]]; then
        # Get downloaded ZIP's phishin.json and output to stdout
        bsdtar -Oxf "${zip}" phishin.json
    fi
)

# If the far and near show data differs (either $near_show_data is empty and
# far is not or whatever) then we need to download the show again.
# shellcheck disable=SC2312
if
    [[ -n "${near_show_data}" ]] \
        && [[ -d "${directory}" ]] \
        && ! cmp -s <(jq -c <<<"${phishin_show_data}" || printf '{}') <(jq -c <<<"${near_show_data}" || printf '{}')
then
    # and if none of this is true, then we don't need to do anything!
    printf '%s: downloaded version is up to date\n' "${show}" >&2
    printf '%s\n' "${directory}"
    exit 0
fi

if ! [[ -d "${directory}" ]]; then
    # Download the album, continuing an unfinished previous download if it exists.
    zip_raw="${zip%.zip}.raw.zip"
    if ! [[ -s "${zip_raw}" ]] && ! [[ -s "${zip}" ]]; then
        # Fetch the ZIP from Phish.in, with progress, and continuing if
        # an unfinished download exists.

        edo curl \
            --location \
            --fail \
            -# \
            -o "${zip_raw}".part \
            --continue-at - \
            "${album_zip_url}" || exit 1

        edo mv "${zip_raw}.part" "${zip_raw}"
    fi

    [[ "$only_download" == false ]] || exit

    # Take time to re-create the ZIP archive generated by Phish.in, and slip in a
    # phishin.json data file that contains the show data from the API while we're
    # at it.
    if [[ -s "$zip_raw" ]] && ! [[ -s "${zip}" ]]; then
        repack=$(mktemp -d)
        repack_album="${repack}/${filename}"
        edo mkdir -p "$repack_album"

        # This is done before extracting in hopes that maybe some day Phish.in
        # will slip a phishin.json into the show archive itself.
        printf '%s' "${phishin_show_data:?}" >"$repack_album"/phishin.json

        # Extract the unedited archive into the album directory,
        # and then remove the archive from the working directory.
        edo bsdtar -C "$repack_album" -xf "${zip_raw}"

        # Use a more default cover filename, and don't include the captionless
        # version of the AI slop art.
        edo rm -f "$repack_album"/cover_art.jpg
        edo mv "$repack_album"/album_cover.jpg "$repack_album"/cover.jpg

        # Repack it, with a leading subdirectory
        edo bsdtar -C "$repack" -cf "${zip}".part "${filename}"/
        edo mv "${zip}".part "${zip}"

        edo rm -rf "$repack"
    fi

    [[ -e "$zip" ]] || exit 1

    edo rm -f "$zip_raw"

    if ! edo bsdtar -xf "${zip}"; then
        printf 'error: failed while extracting downloaded album (%s)\n' "${zip@Q}" >&2
        exit 1
    fi
fi

[[ "$keep_archive" == true ]] || edo rm -f "${zip}"

# Process the show data to get data pertaining to the track file in question,
# and output it all in format suitable for `eval`.
# shellcheck disable=SC2016
jq_script='
    .tracks[$file_i]
        | {
            phishin_track: tojson,
            album: "\(.show_date): \(.venue_name), \(.venue_location)",
            show_date,
            title,
            set_name,
            track_url: "https://phish.in/\(.show_date)/\(.slug)",
            comments: [ (.tags[] | select(.notes != null) | "\(.name): \(.notes)") ] | join("\n")
        }
        | to_entries
        | map("\(.key)=\(.value|@sh)")[]

'

# Work through the downloaded MP3s in the archive, and modify the tags
# given to be nicer and more informative by default; set disc numbers to be
# the show set number; set the recording date to be correct; set a disc subtitle
# to the set name; set the publisher webpage to the track's Phish.in permalink;
# put Phish.in track tags (Jamcharts, Teases, etc.) in the comments.
set_name=
file_i=0
disc=1

for file in "${directory}"/*.mp3; do
    if ! [[ -e "$file" ]]; then
        printf 'error: file %s does not exist\n' "${file@Q}" >&2
        exit 1
    fi

    last_set_name="${last_set_name:-${set_name:-}}"

    jq_eval=$(jq -r --argjson file_i "$file_i" "$jq_script" <<<"${phishin_show_data}")
    eval "$jq_eval"

    if [[ "${set_name}" != "${last_set_name}" ]]; then
        disc=$((disc + 1))
    fi

    : "${album:?}"
    : "${title:?}"
    : "${show_date:?}"
    : "${set_name:?}"
    : "${track_url:?}"
    : "${comments?}"

    # Tageditor yaps a lot
    {
        # Tageditor doesn't know about TSST, the disc subtitle tag in ID3.
        edo tageditor set \
            album="${album}" title="${title}" \
            year="${show_date:0:4}" recorddate="${show_date}" \
            disk="${disc}" id3:TSST="${set_name}" \
            comment="${comments}" publisherwebpage="${track_url}" \
            --id3v1-usage never \
            --id3v2-version 4 \
            --encoding utf8 \
            --quiet \
            --files "${file}"
        rm -f "${file}".bak
    } >/dev/null

    last_set_name="${set_name}"
    file_i=$((file_i + 1))
done

[[ "$keep_archive" == true ]] || edo rm -f "${zip}"

# Everything went fine so now print the downloaded show on stdout to indicate
# to any other tools listening that the show in question has been downloaded.
printf '%s\n' "${directory}"
