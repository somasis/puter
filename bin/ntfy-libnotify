#!/usr/bin/env bash
#!/usr/bin/env nix-shell
#! nix-shell -i bash -p bash curl imagemagick jq libnotify pup sed xurls
# shellcheck shell=bash
# vim: ft=sh

set -euo pipefail

# shellcheck disable=SC2120
usage() {
    # shellcheck disable=SC2059
    [[ "$#" -eq 0 ]] || printf "$@" >&2

    cat >&2 <<EOF
usage: ntfy subscribe <topic> ${0##*/} [-v]

Show a desktop notification sent to ntfy.sh, using \`notify-send\`. How this
differs from just using \`notify-send "\$NTFY_TITLE" "\$NTFY_MESSAGE"\`,
is that this script takes care to translate the ntfy.sh notification metadata
to its freedesktop.org notification specification equivalents.

Example usage in ${XDG_CONFIG_HOME:-$HOME/.config}/ntfy/client.yaml:
\`\`\`yaml
default-command: ${0##*/}

# and/or

subscribe:
  - topic: zfs-scrubs
    command: ${0##*/}
\`\`\`

options:
    -v              Be more verbose, printing commands as they are ran.

environment variables:
    \$XDG_CONFIG_HOME${XDG_CONFIG_HOME:+ (current: ${XDG_CONFIG_HOME@Q})}
    \$NTFY_MESSAGE, \$NTFY_PRIORITY, \$NTFY_RAW, \$NTFY_TAGS, \$NTFY_TITLE
        These variables should be set when invoked by \`ntfy subscribe\`.

Kylie McClain <kylie@somas.is>
EOF
    [[ "$#" -eq 0 ]] || exit 1
    exit 64 # EX_USAGE
}

edo() {
    local arg string
    string="$"
    for arg; do
        if [[ "${arg@Q}" == "'$arg'" ]] && ! [[ "${arg}" =~ [[:blank:]] ]]; then
            string+=" $arg"
        else
            string+=" ${arg@Q}"
        fi
    done

    if [[ "${verbosity}" -ge 1 ]]; then
        printf '%s\n' "$string" >&2 || :
    fi

    "$@"
}

verbosity=0
while [[ "$#" -gt 0 ]]; do
    case "${1}" in
        --help) usage ;;
        -v) verbosity=$((verbosity + 1)) ;;
    esac
    shift
done

: "${NTFY_RAW?error: \$NTFY_RAW was not set; are you running this script from within \`ntfy subscribe\`?}"
: "${NTFY_ID:=}"
: "${NTFY_MESSAGE:=}"
: "${NTFY_TITLE:=}"
: "${NTFY_TAGS:=}"
: "${NTFY_PRIORITY:=0}"

: "${XDG_RUNTIME_DIR:=/run/user/$(id -u)}"

NTFY_TAGS=()
mapfile -t NTFY_TAGS < <(jq -r '.tags // ""' <<<"${NTFY_RAW}")

NTFY_TOPIC=$(jq -rc '.topic // ""' <<<"${NTFY_RAW}")
NTFY_CLICK=$(jq -rc '.click // ""' <<<"${NTFY_RAW}")
NTFY_ICON=$(jq -rc '.icon // .attachment.url // ""' <<<"${NTFY_RAW}")

message_is_markdown=$(jq -r '.content_type == "text/markdown"' <<<"${NTFY_RAW}")

args=()

app_name="${NTFY_TOPIC:-ntfy}"
title="$NTFY_TITLE"
urgency=

case "${NTFY_PRIORITY}" in
    1) urgency=low ;;
    2)
        args+=(--transient)
        urgency=low
        ;;
    0 | 3) urgency=normal ;;
    4) urgency=normal ;;
    5) urgency=critical ;;
    *)
        printf 'error: invalid priority: %s\n' "${NTFY_PRIORITY}" >&2
        exit 64
        ;;
esac

case "${title,,}" in
    "${app_name,,}: "*)
        title=${title#*: }
        ;;
    "${app_name,,} - "*)
        title=${title#* - }
        ;;
esac

for tag in "${NTFY_TAGS[@]}"; do
    case "${tag}" in
        origin:*)
            # Put the origin of the notification in the appname, if available
            app_name=${app_name:+"$app_name Â· ${tag#origin:}"}
            ;;
    esac
done

args+=(
    ${urgency:+--urgency="$urgency"}
    ${app_name:+--app-name="$app_name"}
)

message="${NTFY_MESSAGE:-}"
if [[ "$message_is_markdown" == true ]]; then
    # Hastily translate Markdown into Pango markup
    # TODO there's this tool that would (kinda) fit the job, is it any good?
    # <https://world.pages.gitlab.gnome.org/html2pango/html2pango/>
    message=$(
        # shellcheck disable=SC2016
        <<<"$message" sed -E \
            -e '/^# / { s:# :<big><big><big><big>:; s:$:</big></big></big></big>:; }' \
            -e '/^## / { s:## :<big><big><big>:; s:$:</big></big></big>:; }' \
            -e '/^### / { s:### :<big><big>:; s:$:</big></big>:; }' \
            -e '/^#### / { s:#### :<big>:; s:$:</big>:; }' \
            -e '/^##### / { s:##### :<big>:; s:$:</big>:; }' \
            -e '/^###### / { s:###### :<big>:; s:$:</big>:; }' \
            -e 's:\*\*\*(.+)\*\*\*:<i><b>\1</b></i>:g' \
            -e 's:___(.+)___:<i><b>\1</b></i>:g' \
            -e 's:\*\*(.+)\*\*:<b>\1</b>:g' \
            -e 's:__(.+)__:<b>\1</b>:g' \
            -e 's:\*(.+)\*:<i>\1</i>:g' \
            -e 's:(\W*)_(.+)_(\W*):\1<i>\2</i>\3:g' \
            -e 's,([^!]?)\[([^\]]+)\]\((\S+)\),<a href=\3>\2</a>,g' \
            -e 's,!\[([^\]]+)\]\((\S+)\),<a href=\2>\1 (image)</a>,g' \
            -e 's:`(.+)`:<tt>\1</tt>:g'
    )

    # We can't use a Markdown interpreter and just translate it to HTML
    # and then cull unsupported tags because that'd open an even bigger
    # can of worms, I guess...
    # message=$(
    #     pandoc \
    #         -f markdown_strict-raw-html \
    #         -t html-empty_paragraphs-line_blocks-native_divs-native_spans-auto_identifiers \
    #         -o - \
    #         <<<"$message"
    # )
else
    mapfile -t urls < <(xurls <<<"${message}")

    for url in "${urls[@]}"; do
        url_hyperlink="<a href=\"${url}\">${url}</a>"
        message=${message/"$url"/"$url_hyperlink"}
    done
fi

if [[ -z "$NTFY_ICON" ]] && [[ -n "$NTFY_CLICK" ]]; then
    NTFY_ICON=$(
        edo curl \
            --user-agent 'ntfy-libnotify <kylie@somas.is>' \
            --location \
            --globoff \
            --url "$NTFY_CLICK" \
            | pup '
                head meta[property$=:image] attr{content},
                head link[type^="image/"] attr{href}
            ' \
            | while IFS= read -r url; do
                case "$url" in
                    /*) url="${NTFY_CLICK}/${url}" ;;
                esac

                edo curl \
                    --user-agent '' \
                    --location \
                    --silent \
                    --globoff \
                    --url "$url" \
                    --head \
                    --output /dev/stderr \
                    --write-out '%{url}\n' \
                    2>/dev/null
            done \
            | head -n1
    )
fi

icon_url=
icon_file=
if [[ -n "${NTFY_ICON:-}" ]] && [[ "${NTFY_ICON:0:1}" != '/' ]]; then
    icon_url="$NTFY_ICON"

    mkdir -p "$XDG_RUNTIME_DIR/ntfy-libnotify"
    icon_file="${XDG_RUNTIME_DIR}/ntfy-libnotify/${icon_url##*/}"

    edo curl --silent \
        --user-agent 'ntfy-libnotify <kylie@somas.is>' \
        --globoff \
        --location \
        --fail \
        --compressed \
        --output "${icon_file}" \
        --url "${icon_url}"

    edo magick convert "${icon_file}" "${icon_file%.*}.png"
    icon_file="${icon_file%.*}.png"
fi

if [[ -n "${icon_file}" ]]; then
    args+=(--icon="${icon_file}")
fi

if [[ -n "${NTFY_CLICK:-}" ]]; then
    args+=(--action=click=Open)
    # feels like the wrong way to make the actions persist for longer
    # args+=(--expire-time=$((60 * 1000)))
fi

[[ "${title:-$NTFY_MESSAGE}" != "$message" ]] || title=

(
    action=$(
        edo notify-send "${args[@]}" -- \
            "${title}" \
            "${message}"
    )

    case "${action}" in
        click)
            edo xdg-open "${NTFY_CLICK}" &
            disown
            ;;
    esac

    [[ -n "$icon_file" ]] && rm -f "$icon_file"
) &
disown
