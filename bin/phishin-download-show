#!/usr/bin/env bash
#!/usr/bin/env nix-shell
#! nix-shell -i bash -p bash coreutils curl diffutils jq libarchive rsync tageditor
# shellcheck shell=bash

set -euo pipefail

command -V \
    bsdtar \
    cmp \
    curl \
    jq \
    rsync \
    tageditor \
    >/dev/null || exit 1

usage() {
    # shellcheck disable=SC2059
    [[ "$#" -eq 0 ]] || printf "$@" >&2

    cat >&2 <<EOF
usage: ${0##*/} <show>

Download a show from Phish.in to the current directory.

options:
    <show>          An ISO formatted date (ex. 1969-12-31)

see also: the Phish.in project <https://phish.in>.

Kylie McClain <kylie@somas.is>
EOF
    [[ "$#" -eq 0 ]] || exit 1
    exit 64 # EX_USAGE
}

edo() {
    local arg string
    string="$"
    for arg; do
        if [[ "${arg@Q}" == "'$arg'" ]] && ! [[ "${arg}" =~ [[:blank:]] ]]; then
            string+=" $arg"
        else
            string+=" ${arg@Q}"
        fi
    done

    printf '%s\n' "$string" >&2 || :
    "$@"
}

curl() {
    command curl --location --user-agent 'phish-cli <kylie@somas.is>' "$@"
}

phishin() {
    jq -cr "$@" <<<"${phishin_show_data}"
}

[[ "$#" -eq 1 ]] || usage 'error: incorrect number of arguments (1 required)\n'

show=${1:?error: no show provided}

while :; do
    request_album_zip=$(
        jq -nc '{date:$show}' --arg show "${show}" \
            | curl --no-progress-meter --json @- \
                'https://phish.in/api/v2/shows/request_album_zip'
    )

    if jq -re '.message == "Album already generated"' <<<"${request_album_zip}" >/dev/null; then
        break
    else
        sleep 15
    fi
done

# shellcheck disable=SC2310
if ! phishin_show_data=$(
    curl --no-progress-meter --fail "https://phish.in/api/v2/shows/${show}" \
        | jq -c
); then
    printf 'error: failed to download show data for %s\n' "${show}" >&2
    exit 1
fi

near_show_data=

show_download=$(
    phishin '{
        album_zip_url,
        updated_at,
        filename: (
            [
                "Phish - \(.date) \(.venue_name), \(.venue.location)",
                ((
                    ( .tags | map(.name))
                        + [
                            (.audio_status
                                | (
                                    (.[0:1] | ascii_upcase)
                                        + .[1:]
                                )
                            )
                        ]
                ) | map(" [\(.)]") | join("")),
                ".zip"
            ] | join("")
        )
    }'
)

filename=$(jq -r .filename <<<"${show_download}")
directory="${PWD}/${filename%.zip}"
zip="${PWD}/${filename}"

album_zip_url=$(jq -r .album_zip_url <<<"${show_download}")

near_show_data=$(
    if [[ -f "${zip}" ]]; then
        if bsdtar -tf "${zip}" | grep -Fq phishin.json; then
            bsdtar -Oxf "${zip}" phishin.json
        fi
    elif [[ -f "${directory}"/phishin.json ]]; then
        cat "${directory}"/phishin.json
    fi
)

extract_to_temp=$(mktemp -d)
if ! [[ -d "${directory}" ]]; then
    if ! [[ -f "${zip}" ]]; then
        edo curl \
            --location \
            --fail \
            -# \
            -o "${zip}".part.zip \
            --continue-at - \
            --remote-time \
            "${album_zip_url}" || exit 1

        temp=$(mktemp -d)
        printf '%s' "${phishin_show_data:?}" >"$temp"/phishin.json
        edo bsdtar -C "$temp" -acf - @"$zip".part.zip phishin.json \
            | edo sponge "$zip".part.zip
        edo rm -rf "$temp"
        edo mv "$zip".part.zip "$zip"
    fi
    edo mkdir -p "${directory}"
    if ! edo bsdtar -C "${extract_to_temp}" -xf "${zip}"; then
        printf 'error: failed while extracting downloaded album (%s)\n' "${zip@Q}" >&2
        exit 1
    fi

    rm -f "${extract_to_temp}"/cover_art.jpg
    mv "${extract_to_temp}"/album_cover.jpg "${extract_to_temp}"/cover.jpg

    edo rsync --remove-source-files --delete -ru "${extract_to_temp}"/ "${directory}"/
    rm -rf "${extract_to_temp}"
fi

# If the far and near show data differs (either $near_show_data is empty and
# far is not or whatever) then we need to download the show again.
# shellcheck disable=SC2312
if
    [[ -n "${near_show_data}" ]] \
        && [[ -d "${directory}" ]] \
        && ! cmp -s <(jq -c <<<"${phishin_show_data}" || printf '{}') <(jq -c <<<"${near_show_data}" || printf '{}')
then
    # and if none of this is true, then we don't need to do anything!
    printf '%s: downloaded version is up to date\n' "${show}" >&2
    printf '%s\n' "${directory}"
    exit 0
fi

# Go through the files and actually enhance the tagging ourselves
set_name=
file_i=0
disc=1

# shellcheck disable=SC2016
jq_script='
    .tracks[$file_i]
        | {
            phishin_track: tojson,
            album: "\(.show_date): \(.venue_name), \(.venue_location)",
            show_date,
            title,
            set_name,
            track_url: "https://phish.in/\(.show_date)/\(.slug)",
            comments: [ (.tags[] | select(.notes != null) | .notes) ] | join("\n")
        }
        | to_entries
        | map("\(.key)=\(.value|@sh)")[]

'
for file in "${directory}"/*.mp3; do
    if ! [[ -e "$file" ]]; then
        printf 'error: file %s does not exist\n' "${file@Q}" >&2
        exit 1
    fi

    last_set_name="${last_set_name:-${set_name:-}}"

    jq_eval=$(jq -r --argjson file_i "$file_i" "$jq_script" <<<"${phishin_show_data}")
    eval "$jq_eval"

    if [[ "${set_name}" != "${last_set_name}" ]]; then
        disc=$((disc + 1))
    fi

    : "${album:?}"
    : "${title:?}"
    : "${show_date:?}"
    : "${set_name:?}"
    : "${track_url:?}"
    : "${comments?}"

    # Tageditor yaps a lot
    {
        # Tageditor doesn't know about TSST, the disc subtitle tag in ID3.
        tageditor set \
            album="${album}" title="${title}" \
            year="${show_date:0:4}" recorddate="${show_date}" \
            disk="${disc}" id3:TSST="${set_name}" \
            comment="${comments}" publisherwebpage="${track_url}" \
            --quiet \
            --id3v1-usage never \
            --id3v2-version 4 \
            --files "${file}"
        rm -f "${file}".bak
    } >/dev/null

    last_set_name="${set_name}"
    file_i=$((file_i + 1))
done

rm -f "${zip}"

# Everything went fine so now print the downloaded show on stdout to indicate to any other tools
# that the show in question has been downloaded.
printf '%s\n' "${directory}"
