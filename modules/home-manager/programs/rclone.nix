{ config
, lib
, osConfig
, pkgs
, ...
}:
let
  inherit (lib) options types;
  inherit (options) mkEnableOption mkOption;

  rcloneCfg = config.programs.rclone;
  rclonePkg = rcloneCfg.package;
  rcloneExe = lib.getExe rclonePkg;

  rcloneConfigValue =
    v:
    if builtins.isNull v then
      ""
    else if builtins.isList v then
      lib.concatMapStringsSep "," (item: lib.generators.mkValueStringDefault { } item) v
    else
      lib.generators.mkValueStringDefault { } v;

  rcloneFormat = pkgs.formats.ini {
    listToValue = rcloneConfigValue;
    mkKeyValue = lib.generators.mkKeyValueDefault { mkValueString = rcloneConfigValue; } "=";
  };
in
{
  options.programs.rclone = {
    enable = mkEnableOption "Enable rclone";

    package = mkOption {
      type = types.package;
      default = pkgs.rclone;
      defaultText = options.literalExpression "pkgs.rclone";
      description = "The rclone package to use.";
    };

    # finalPackage = mkOption {
    #   type = types.package;
    #   description = ''
    #     The actual package that will be included in the user environment.
    #   '';

    #   readOnly = true;
    #   defaultText = ''
    #     If programs.rclone.extraOptions is non-empty, programs.rclone.package + extraOptions prepended as flags.
    #     If empty, programs.rclone.package unwrapped.
    #   '';
    # };

    daemon = {
      enable = mkEnableOption "Enable rclone remote control daemon";
      settings = mkOption {
        type = with types; attrsOf;
        default = { };
        description = ''
          Flags to pass to `rclone rcd`.
          See `rclone rcd --help` for details.
        '';
      };
    };

    extraOptions = mkOption {
      type = with types; listOf nonEmptyStr;
      description = ''
        Extra arguments to pass to `rclone` invocations by default.
        See `rclone help flags` for a list of supported global flags, networking-related flags, etc.
      '';
      default = [ ];
      example = [
        "--bwlimit"
        "512K"
      ];
    };

    remotes = mkOption {
      inherit (rcloneFormat) type;
      description = ''
        Remotes to configure in `rclone`.

        See `rclone help backends` for a list of supported remote types.

        Note that rclone configuration is not pure declarative.
        Since the configuration can be modified by rclone during runtime,
        a static configuration file cannot be generated by home-manager
        without it being overwritten at some point and causing file
        collisions eventually.

        Instead, at profile activation, remote settings will be merged
        into the existing rclone configuration, using the `add` and
        `update` subcommands of `rclone config`.

        Do not put passwords in any remote settings! They will be
        world-readable since the generated config is placed in the
        Nix store. Set them manually using `rclone config reconnect`,
        `rclone config password`, etc.
      '';

      default = { };
      example = {
        seedbox = {
          type = "sftp";
          host = "ssh.nsa.gov";
          user = "esnowden";

          ask_password = false;
          key_file = "~/.ssh/id_ed25519";
          known_hosts_file = "~/.ssh/known_hosts";
        };
      };
    };
  };

  config = lib.mkIf config.programs.rclone.enable {
    # assertions = [{
    #   assertion =
    #     let
    #       configuredRemotes = builtins.attrNames rcloneCfg.remotes;
    #       configuredMounts = builtins.attrNames mountsCfg.mounts;

    #       invalidMounts =
    #         lib.filter
    #           (remote: lib.lists.any (configuredRemote: configuredRemote == remote) configuredRemotes)
    #           configuredMounts
    #       ;
    #     in
    #     if mountsCfg.enable && mountsCfg.mounts != { } then
    #       invalidMounts == 0
    #     else
    #       true
    #   ;
    #   message = "Each configured mount must match a configured rclone remote";
    # }];

    # programs.rclone.finalPackage =
    #   if rcloneCfg.extraOptions != [ ] then
    #     (pkgs.wrapCommand {
    #       package = rcloneCfg.package;
    #       wrappers = [{
    #         command = "/bin/rclone";
    #         prependFlags = lib.escapeShellArgs rcloneCfg.extraOptions;
    #       }];
    #     })
    #   else
    #     rcloneCfg.package
    # ;

    home = {
      packages = [ config.programs.rclone.package ];

      activation.applyRcloneSettings = lib.mkIf (config.programs.rclone.remotes != { }) (
        lib.hm.dag.entryAfter [ "writeBoundary" "installPackages" ] (
          let
            # getRemovedKeys = pkgs.writeJqScript "get-removed-keys.jq" { null-input = true; raw-output = true; } ''
            #   [
            #     (
            #       input as $configured
            #         | input as $actual
            #         | $actual
            #         | delpaths([(
            #           $configured
            #             | paths
            #             | select(length > 1)
            #             | select(.[1] != "token")
            #         )])
            #         | paths
            #         | select(length > 1))
            #   ] | map(select(.[1] != "token"))
            # ''
            # ;

            # json2ini = pkgs.writeJqScript "json2ini.jq" { raw-output = true; } ''
            #   to_entries
            #     | map(
            #       "[\(.key)]",
            #       (.value | to_entries[] | "\(.key) = \(.value)"),
            #       ""
            #     )[]
            # '';

            # prune-rclone-config = ''
            #   rclone_removed_paths=$(
            #       ${getRemovedKeys} \
            #           <(${rcloneExe} --config ${rcloneFormat.generate "generated-rclone.conf" rcloneCfg.remotes} config dump) \
            #           <(${rcloneExe} --config ${lib.escapeShellArg config.xdg.configHome}/rclone/rclone.conf config dump)
            #   )

            #   ${rcloneExe} config dump \
            #       | ${lib.getExe pkgs.jq} -r --argjson removedPaths "$rclone_removed_paths" 'delpaths($removedPaths)' \
            #       | ${json2ini} \
            #       | ${pkgs.moreutils}/bin/sponge ${lib.escapeShellArg config.xdg.configHome}/rclone/rclone.conf
            # '';

            setRemoteSetting = remote: key: value: ''
              ${lib.toShellVar "rclone_remote" remote}
              ${lib.toShellVar "rclone_key" key}
              ${lib.toShellVar "rclone_value" (rcloneConfigValue value)}

              # verboseEcho "$(${rcloneExe} config dump | ${pkgs.jq}/bin/jq -rc '"rclone config: \(.)"')"

              if rclone_has_remote "$rclone_remote"; then
                  if rclone_has_setting "$rclone_remote" "$rclone_key" "$rclone_value"; then
                      verboseEcho "not updating rclone remote '$rclone_remote' setting '$rclone_key', as it is already set to that"
                  else
                      verboseEcho "updating rclone remote '$rclone_remote' setting '$rclone_key'"

                      if [[ -v DRY_RUN ]]; then
                          verboseEcho "would update setting for rclone remote '$rclone_remote' setting '$rclone_key'"
                      else
                          if run ${rcloneExe} config update "$rclone_remote" "$rclone_key=$rclone_value" --non-interactive --no-obscure >/dev/null; then
                              verboseEcho "updated rclone remote '$rclone_remote' setting '$rclone_key'"
                          else
                              errorEcho "error while updating rclone remote '$rclone_remote' setting '$rclone_key'"
                          fi
                      fi
                  fi
              else
                  if [[ "$rclone_key" == "type" ]]; then
                      if [[ -v DRY_RUN ]]; then
                          verboseEcho "would create rclone remote '$rclone_remote'"
                      else
                          rclone_config_output=$(run ${rcloneExe} config create "$rclone_remote" "$rclone_value" --non-interactive --no-obscure)
                          if [[ $? -eq 0 ]]; then
                              noteEcho "created rclone remote '$rclone_remote'"

                              if ${pkgs.jq}/bin/jq -e '.State != "" or .Option.Required == true or .Error != ""' >/dev/null <<< "$rclone_config_output"; then
                                  warnEcho \
                                       $'    rclone indicated that there might be more to configure for this remote; consider running:\n' \
                                       '    $ rclone config reconnect '"$rclone_remote:"$'\n' \
                                       '    to configure this remote further.'
                              fi
                          else
                              errorEcho "ran into an error while creating remote '$rclone_remote'"
                          fi
                      fi
                  else
                      errorEcho "rclone does not have remote '$rclone_remote', but we tried to add setting '$rclone_key'"
                      # run ${rcloneExe} config create "$rclone_remote" "$rclone_key=$rclone_value" --non-interactive --no-obscure
                  fi
              fi
            '';

            settingCommands = lib.mapAttrsToList
              (
                remote: remoteSettings:
                  # Ensure `type` is always the first attribute. `rclone config create` needs a type
                  # when creating a remote, and it would complicate activation script logic if we
                  # needed to keep track of the `type` in order to process further remote settings.
                  [ (setRemoteSetting remote "type" remoteSettings.type) ]
                  ++ lib.mapAttrsToList (setRemoteSetting remote) (builtins.removeAttrs remoteSettings [ "type" ])
              )
              config.programs.rclone.remotes;
          in
          # $VERBOSE_ECHO "Pruning rclone configuration of any removed keys"
            # $DRY_RUN_CMD ${prune-rclone-config}
            # verboseEcho "Setting rclone configuration"
          ''
            rclone_has_remote() {
                local remote="$1"; remote=''${remote%%,*}

                ${rcloneExe} config dump \
                    | ${pkgs.jq}/bin/jq -e \
                        --arg remote "$remote" \
                        'to_entries | map(select(.key == $remote)) != []' \
                        >/dev/null
            }

            rclone_has_setting() {
                local remote="$1"; remote=''${remote%%,*}
                local key="$2"
                local value="$3"

                ${rcloneExe} config dump \
                    | ${pkgs.jq}/bin/jq -e \
                        --arg remote "$remote" \
                        --arg key "$key" \
                        --arg value "$value" '
                        to_entries
                          | map(
                            select(.key == $remote) | .value | to_entries[]
                              | select(.key == $key and .value == $value)
                          ) != []
                        ' \
                        >/dev/null
            }
          ''
          + (lib.concatMapStrings lib.concatStrings settingCommands)
        )
      );
    };
  };
}
